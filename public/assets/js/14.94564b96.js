(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{458:function(t,s,a){t.exports=a.p+"assets/img/04.9f1990d2.png"},642:function(t,s,a){t.exports=a.p+"assets/img/01.c012ba1b.png"},643:function(t,s,a){t.exports=a.p+"assets/img/02.ee996a85.png"},644:function(t,s,a){t.exports=a.p+"assets/img/03.c8a5f5c8.png"},645:function(t,s,a){t.exports=a.p+"assets/img/06.f9e6fd15.png"},646:function(t,s,a){t.exports=a.p+"assets/img/07.62288275.png"},647:function(t,s,a){t.exports=a.p+"assets/img/08.bd3365a6.png"},648:function(t,s,a){t.exports=a.p+"assets/img/09.1112763b.png"},649:function(t,s,a){t.exports=a.p+"assets/img/10.c6453489.png"},650:function(t,s,a){t.exports=a.p+"assets/img/11.49e0e915.png"},651:function(t,s,a){t.exports=a.p+"assets/img/12.e2c26b88.png"},775:function(t,s,a){"use strict";a.r(s);var r=a(8),_=Object(r.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("blockquote",[r("p",[t._v("现代的OS基本都是多道处理系统，也就意味着一个操作系统会"),r("strong",[t._v("并发")]),t._v('运行多个程序，为了方便描述和控制这些“Running Application",人们引入了进程的概念。')])]),t._v(" "),r("h2",{attrs:{id:"进程实体"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程实体"}},[t._v("#")]),t._v(" 进程实体")]),t._v(" "),r("h3",{attrs:{id:"主存中的进程形态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主存中的进程形态"}},[t._v("#")]),t._v(" 主存中的进程形态")]),t._v(" "),r("p",[t._v("主存中的进程是一段连续存储的空间，这段空间被称之为"),r("strong",[t._v("进程控制块")]),t._v("。进程控制块是用于描述和控制进程的数据结构，同时它也是使得进程能够独立运行的基本单位。\n"),r("img",{attrs:{src:a(642),alt:""}})]),t._v(" "),r("ul",[r("li",[t._v("标志符:用来标记一个进程，用于区别其他进程。")]),t._v(" "),r("li",[t._v("状态：用来标记进程的状态，如“阻塞态”，“运行态”等等。")]),t._v(" "),r("li",[t._v("程序计数器：和计组中的计数器概念差不多，用来存储进程即将执行下一条指令的地址。")]),t._v(" "),r("li",[t._v("内存指针：存储和程序指针以及进程位置相关的信息。")]),t._v(" "),r("li",[t._v("上下文：上下文区域存储的是当前进程正在执行时CPU中的"),r("strong",[t._v("寄存器和高速缓存中数据")]),t._v("。")]),t._v(" "),r("li",[t._v("IO状态信息：记录当进程执行IO操作时所占用的文件列表。")]),t._v(" "),r("li",[t._v("记账信息：记录进程使用CPU的时间，时钟数总和等等。")])]),t._v(" "),r("p",[t._v("由于PCB要经常被读取，因此它会被OS置于一块常驻的区域内存中。")]),t._v(" "),r("h3",{attrs:{id:"进程与线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[t._v("#")]),t._v(" 进程与线程")]),t._v(" "),r("p",[t._v("进程是进行资源分配与调度的"),r("strong",[t._v("基本单位")]),t._v("，"),r("strong",[t._v("拥有")]),t._v("一定的资源，通过进程IPC进行通信。\n线程是操作系统进行调度的"),r("strong",[t._v("最小单位")]),t._v("，线程"),r("strong",[t._v("不拥有")]),t._v("资源，但它可以"),r("strong",[t._v("共享")]),t._v("进程的资源。线程只能通过读写同一进程的数据进行通信。")]),t._v(" "),r("h2",{attrs:{id:"五状态模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#五状态模型"}},[t._v("#")]),t._v(" 五状态模型")]),t._v(" "),r("h3",{attrs:{id:"创建状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建状态"}},[t._v("#")]),t._v(" 创建状态")]),t._v(" "),r("p",[t._v("当进程"),r("strong",[t._v("拥有PCB")]),t._v("但是其他所有资源还没就绪的状态。")]),t._v(" "),r("p",[t._v("操作系统会提供fork()函数接口来让应用程序创建进程。")]),t._v(" "),r("h3",{attrs:{id:"就绪状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#就绪状态"}},[t._v("#")]),t._v(" 就绪状态")]),t._v(" "),r("p",[t._v("当进程所需要的所有资源都准备好，但只差"),r("strong",[t._v("CPU资源")]),t._v("的时候，我们就可以说进程进入了"),r("strong",[t._v("就绪状态")]),t._v("。\n"),r("img",{attrs:{src:a(643),alt:""}}),t._v("\n当多个进程处于就绪状态的时候，它们会形成"),r("strong",[t._v("就绪队列")]),t._v("。")]),t._v(" "),r("h3",{attrs:{id:"执行状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#执行状态"}},[t._v("#")]),t._v(" 执行状态")]),t._v(" "),r("p",[t._v("当进程获得全部资源（包括CPU资源），此时就会进入"),r("strong",[t._v("执行状态")]),t._v("。")]),t._v(" "),r("blockquote",[r("p",[t._v("在单处理机中，某个时刻内只能有一个进程处于执行态。")])]),t._v(" "),r("h3",{attrs:{id:"阻塞状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#阻塞状态"}},[t._v("#")]),t._v(" 阻塞状态")]),t._v(" "),r("p",[t._v("当进程由于缺少资源（最典型的是发起IO请求）而放弃CPU的时候，我们就可以说此时进程处于阻塞状态。\n"),r("img",{attrs:{src:a(644),alt:""}}),t._v("\n当多个进程处于阻塞状态时，它们就会形成"),r("strong",[t._v("阻塞队列")]),t._v("。")]),t._v(" "),r("h3",{attrs:{id:"终止状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#终止状态"}},[t._v("#")]),t._v(" 终止状态")]),t._v(" "),r("p",[t._v("当进程结束被"),r("strong",[t._v("系统回收")]),t._v("(此时会归还PCB)的状态。")]),t._v(" "),r("h3",{attrs:{id:"五状态之间的转换"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#五状态之间的转换"}},[t._v("#")]),t._v(" 五状态之间的转换")]),t._v(" "),r("p",[r("img",{attrs:{src:a(458),alt:""}}),t._v("\n当进程被创建后，并且获得了"),r("strong",[t._v("除CPU资源的所有资源")]),t._v("，就会进入就绪状态(或进入就绪队列)。在就绪状态，一旦被"),r("strong",[t._v("调度")]),t._v("（获得CPU资源），就会进入执行态。反之，如果不被调度（CPU资源用完），就会重新返回就绪态。当进程在执行态发起IO请求时，就会进入阻塞态。IO操作一旦完成，会回到就绪态，等待被调度。当进程在执行态运行完成后，会归还PCB，并进入终止态。")]),t._v(" "),r("h2",{attrs:{id:"进程同步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程同步"}},[t._v("#")]),t._v(" 进程同步")]),t._v(" "),r("h3",{attrs:{id:"为什么需要引入进程同步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要引入进程同步"}},[t._v("#")]),t._v(" 为什么需要引入进程同步")]),t._v(" "),r("p",[t._v("在解释这个问题之前，首先要引入两个著名的问题。")]),t._v(" "),r("h4",{attrs:{id:"生产者-消费者问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生产者-消费者问题"}},[t._v("#")]),t._v(" 生产者-消费者问题")]),t._v(" "),r("p",[r("em",[t._v("有一群生产者在生产产品，生产完成后会将产品放入仓库，同时有一群消费者在消费产品，它们会从仓库中拿走产品并消费。")])]),t._v(" "),r("p",[t._v("这个问题在宏观条件下并不会出现什么差错，但类比放入计算机中的时候，就会出现问题。")]),t._v(" "),r("div",{staticClass:"language-c++ line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <vector>\n\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\nint num = 0;\n//生产者函数，模拟生产1000000个产品\nvoid *producer(void*){\n    int times = 10000000;\n    while(times --){\n        // pthread_mutex_lock(&mutex);\n        num += 1;\n        // pthread_mutex_unlock(&mutex);\n    }\n}\n//消费者函数，模拟消费1000000个产品\nvoid *comsumer(void*){\n    int times = 10000000;\n    while(times --){\n        // pthread_mutex_lock(&mutex);\n        num -= 1;\n        // pthread_mutex_unlock(&mutex);\n    }\n}\n\n\nint main(){\n    printf("Start in main function.");\n    //分别用线程来模拟生产者和消费者\n    pthread_t thread1, thread2;\n    pthread_create(&thread1, NULL, &producer, NULL);\n    pthread_create(&thread2, NULL, &comsumer, NULL);\n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n    printf("Print in main function: num = %d\\n", num);\n    return 0;\n}\n')])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br"),r("span",{staticClass:"line-number"},[t._v("8")]),r("br"),r("span",{staticClass:"line-number"},[t._v("9")]),r("br"),r("span",{staticClass:"line-number"},[t._v("10")]),r("br"),r("span",{staticClass:"line-number"},[t._v("11")]),r("br"),r("span",{staticClass:"line-number"},[t._v("12")]),r("br"),r("span",{staticClass:"line-number"},[t._v("13")]),r("br"),r("span",{staticClass:"line-number"},[t._v("14")]),r("br"),r("span",{staticClass:"line-number"},[t._v("15")]),r("br"),r("span",{staticClass:"line-number"},[t._v("16")]),r("br"),r("span",{staticClass:"line-number"},[t._v("17")]),r("br"),r("span",{staticClass:"line-number"},[t._v("18")]),r("br"),r("span",{staticClass:"line-number"},[t._v("19")]),r("br"),r("span",{staticClass:"line-number"},[t._v("20")]),r("br"),r("span",{staticClass:"line-number"},[t._v("21")]),r("br"),r("span",{staticClass:"line-number"},[t._v("22")]),r("br"),r("span",{staticClass:"line-number"},[t._v("23")]),r("br"),r("span",{staticClass:"line-number"},[t._v("24")]),r("br"),r("span",{staticClass:"line-number"},[t._v("25")]),r("br"),r("span",{staticClass:"line-number"},[t._v("26")]),r("br"),r("span",{staticClass:"line-number"},[t._v("27")]),r("br"),r("span",{staticClass:"line-number"},[t._v("28")]),r("br"),r("span",{staticClass:"line-number"},[t._v("29")]),r("br"),r("span",{staticClass:"line-number"},[t._v("30")]),r("br"),r("span",{staticClass:"line-number"},[t._v("31")]),r("br"),r("span",{staticClass:"line-number"},[t._v("32")]),r("br"),r("span",{staticClass:"line-number"},[t._v("33")]),r("br"),r("span",{staticClass:"line-number"},[t._v("34")]),r("br"),r("span",{staticClass:"line-number"},[t._v("35")]),r("br"),r("span",{staticClass:"line-number"},[t._v("36")]),r("br"),r("span",{staticClass:"line-number"},[t._v("37")]),r("br"),r("span",{staticClass:"line-number"},[t._v("38")]),r("br"),r("span",{staticClass:"line-number"},[t._v("39")]),r("br"),r("span",{staticClass:"line-number"},[t._v("40")]),r("br")])]),r("p",[t._v("上述代码用C++简单模拟了一下生产者-消费者的模型，我们用生产者生产出了1000000个产品，同时又用消费者消费了1000000个产品，理论上来说，我们最终print出来的num应该是0，但结果却很诡异：\n"),r("img",{attrs:{src:a(645),alt:""}})]),t._v(" "),r("p",[t._v("很明显结果是不对的，问题到底出在哪？")]),t._v(" "),r("p",[t._v("问题出在计算机操作“仓库”（缓冲区）的层次上。")]),t._v(" "),r("p",[t._v("当计算机要操作缓冲区时，不管是生产者还是消费者，都要经历三步。")]),t._v(" "),r("ol",[r("li",[t._v("把数据从缓冲区拿出来，放到寄存器里。")]),t._v(" "),r("li",[t._v("在"),r("strong",[t._v("寄存器")]),t._v("里对数据进行操作。")]),t._v(" "),r("li",[t._v("操作完成后将数据放回缓冲区。")])]),t._v(" "),r("p",[r("img",{attrs:{src:a(646),alt:""}}),t._v("\n假如说count是缓冲区，register是寄存器，上述就是一个生产进程一个消费进程顺序执行的理想情况，这肯定是不会出错的。")]),t._v(" "),r("p",[t._v("但如果这两个进程的执行顺序是交叉执行（别忘了现代OS都支持进程并发），最终就的不到想要的结果。\n"),r("img",{attrs:{src:a(647),alt:""}}),t._v("\n上图简单的描述了这种情况。我们很容易发现：生产者进程还没生产完毕，消费者进程的手就伸过来了。那么消费者进程拿到的只能是初始值10，最终一个生产一个消费产生的结果只能是9或11（看这俩进程谁先跑完）。")]),t._v(" "),r("p",[t._v("看到这里我们应该就能想到，如果我们强制性的"),r("strong",[t._v("控制")]),t._v("下他们的执行顺序，就不会产生这种情况。")]),t._v(" "),r("p",[t._v("接下来看第二个问题。")]),t._v(" "),r("h4",{attrs:{id:"哲学家进餐问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#哲学家进餐问题"}},[t._v("#")]),t._v(" 哲学家进餐问题")]),t._v(" "),r("p",[r("img",{attrs:{src:a(648),alt:""}}),t._v("\n假设有五个哲学家，他们每天的生活只有🍚，🤔和😪，他们五个人共用一张桌子，桌子上有五个碗，但是只有五根筷子。当他们饿的时候，会先拿起左边的筷子，再拿起右边的筷子，然后开始吃饭。吃完饭后他们会继续思考。")]),t._v(" "),r("p",[t._v("忽然有一天，发生了一件非常可怕的事情。")]),t._v(" "),r("p",[t._v("他们同时饿了，他们又同时拿了左手边的筷子，由于他们都拿不到右手边的筷子，于是他们就全饿死了。。。")]),t._v(" "),r("p",[t._v("进程在调用资源的时候就很像这几个哲学家，一旦出现这种等待资源的情况，就只能被活活饿死，这种情况叫做"),r("strong",[t._v("死锁")]),t._v("。")]),t._v(" "),r("hr"),t._v(" "),r("p",[t._v("之所以会产生上面两种情况的最本质原因是："),r("strong",[t._v("进程彼此之间没有相互通信")]),t._v("。")]),t._v(" "),r("p",[t._v("假如生产者能够通知消费者自己没有完成生产或已经完成生产，哲学家在吃饭前能够通知邻座的哲学家，都不会出现这种问题。")]),t._v(" "),r("p",[t._v("因此我们需要通过进程同步来帮助"),r("strong",[t._v("控制并发进程和协调临界区资源。")])]),t._v(" "),r("blockquote",[r("p",[r("strong",[t._v("临界区资源")]),t._v("：指的是在计算机中虽然被共享但无法被多个线程共同访问的资源。")])]),t._v(" "),r("h3",{attrs:{id:"进程同步的原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程同步的原则"}},[t._v("#")]),t._v(" 进程同步的原则")]),t._v(" "),r("h4",{attrs:{id:"空闲让进"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#空闲让进"}},[t._v("#")]),t._v(" 空闲让进")]),t._v(" "),r("p",[t._v("当临界资源空闲时，允许进程使用。")]),t._v(" "),r("h4",{attrs:{id:"忙则等待"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#忙则等待"}},[t._v("#")]),t._v(" 忙则等待")]),t._v(" "),r("p",[t._v("当临界资源有人用，需要使用的进程就只能等着。")]),t._v(" "),r("h4",{attrs:{id:"有限等待"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#有限等待"}},[t._v("#")]),t._v(" 有限等待")]),t._v(" "),r("p",[t._v("要保证等待的进程等的时间是有限的，而不是一直在那傻等。")]),t._v(" "),r("h4",{attrs:{id:"让权等待"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#让权等待"}},[t._v("#")]),t._v(" 让权等待")]),t._v(" "),r("p",[t._v("既然进程已经在等临界资源了，那么此时把CPU给它也没啥用啊，菜都没有还怎么做饭。。。不如先把CPU资源让出来（此时就进入了阻塞态）。")]),t._v(" "),r("h3",{attrs:{id:"进程同步的方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程同步的方法"}},[t._v("#")]),t._v(" 进程同步的方法")]),t._v(" "),r("h4",{attrs:{id:"消息队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),r("h4",{attrs:{id:"共享存储"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#共享存储"}},[t._v("#")]),t._v(" 共享存储")]),t._v(" "),r("h4",{attrs:{id:"信号量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#信号量"}},[t._v("#")]),t._v(" 信号量")]),t._v(" "),r("p",[t._v("具体内容请参考下一篇博客，"),r("a",{attrs:{href:""}},[t._v("点此跳转")])]),t._v(" "),r("h3",{attrs:{id:"线程同步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程同步"}},[t._v("#")]),t._v(" 线程同步")]),t._v(" "),r("h4",{attrs:{id:"互斥量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#互斥量"}},[t._v("#")]),t._v(" 互斥量")]),t._v(" "),r("h4",{attrs:{id:"读写锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#读写锁"}},[t._v("#")]),t._v(" 读写锁")]),t._v(" "),r("h4",{attrs:{id:"自旋锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁"}},[t._v("#")]),t._v(" 自旋锁")]),t._v(" "),r("h4",{attrs:{id:"条件变量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#条件变量"}},[t._v("#")]),t._v(" 条件变量")]),t._v(" "),r("p",[t._v("具体内容请参考下一篇博客，"),r("a",{attrs:{href:""}},[t._v("点此跳转")])]),t._v(" "),r("h2",{attrs:{id:"linux的进程管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#linux的进程管理"}},[t._v("#")]),t._v(" Linux的进程管理")]),t._v(" "),r("h3",{attrs:{id:"相关概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#相关概念"}},[t._v("#")]),t._v(" 相关概念")]),t._v(" "),r("h4",{attrs:{id:"进程的类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程的类型"}},[t._v("#")]),t._v(" 进程的类型")]),t._v(" "),r("ul",[r("li",[t._v("前台进程：能在终端界面和用户交互的进程。")]),t._v(" "),r("li",[t._v("后台进程：相对于前台进程，不占用终端界面。执行程序的时候在后面追加一个&就可以以后台进程的方式启动程序。")]),t._v(" "),r("li",[t._v("守护进程：是一类特殊的后台进程，会在系统引导时启动，一直运行到系统关闭。")])]),t._v(" "),r("blockquote",[r("p",[t._v("在linux中，进程名字中以“d”结尾的一般都是守护进程，如cround,httpd,sshd,mysqld等等。")])]),t._v(" "),r("h4",{attrs:{id:"进程的标记"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程的标记"}},[t._v("#")]),t._v(" 进程的标记")]),t._v(" "),r("h5",{attrs:{id:"进程id"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程id"}},[t._v("#")]),t._v(" 进程ID")]),t._v(" "),r("p",[r("img",{attrs:{src:a(649),alt:""}})]),t._v(" "),r("p",[t._v('PID这一列就是"ProcessID",是一个非负整数，最大值由OS确定，用来标识每一个进程。')]),t._v(" "),r("p",[t._v("ID为0的进程是"),r("strong",[t._v("idle")]),t._v("进程，是系统创建的第一个进程。ID为1的进程是init进程，是0号进程的子进程，负责完成系统初始化，同时init也是所有用户进程的祖先进程。")]),t._v(" "),r("blockquote",[r("p",[t._v("在linux中，可以使用pstree命令来查看进程间的继承关系。")])]),t._v(" "),r("h5",{attrs:{id:"进程的状态标记"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程的状态标记"}},[t._v("#")]),t._v(" 进程的状态标记")]),t._v(" "),r("p",[r("img",{attrs:{src:a(650),alt:""}})]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("R")]),t._v(": Running,代表进程正在跑。")]),t._v(" "),r("li",[r("strong",[t._v("S")]),t._v(": Sleeping,代表进程正在处于睡眠状态。")]),t._v(" "),r("li",[r("strong",[t._v("D")]),t._v(": 进程处于IO等待的睡眠状态。")]),t._v(" "),r("li",[r("strong",[t._v("T")]),t._v(": 进程处于暂停状态。")]),t._v(" "),r("li",[r("strong",[t._v("Z")]),t._v(": 进程处于退出状态，或僵尸进程。")])]),t._v(" "),r("h3",{attrs:{id:"操作linux进程的常用命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#操作linux进程的常用命令"}},[t._v("#")]),t._v(" 操作linux进程的常用命令")]),t._v(" "),r("h4",{attrs:{id:"ps命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ps命令"}},[t._v("#")]),t._v(" ps命令")]),t._v(" "),r("p",[t._v("ps命令可以用于查看当前进程的快照。")]),t._v(" "),r("ul",[r("li",[t._v("ps -aux:可以打印所有进程的详细信息。")]),t._v(" "),r("li",[t._v("ps -u [用户名]：查看指定用户的进程。")]),t._v(" "),r("li",[t._v("ps -aux | grep [“进程名”]or[进程号]：可以查看指定进程的详细信息。")]),t._v(" "),r("li",[t._v("ps -aux --sort=-pcpu:根据cpu的使用频率进行排序。")]),t._v(" "),r("li",[t._v("ps -aux --sort=-pmem:根据内存的使用状况进行排序。")]),t._v(" "),r("li",[t._v("ps -ef --forest:打印所有进程的父子状态。")])]),t._v(" "),r("h4",{attrs:{id:"top命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#top命令"}},[t._v("#")]),t._v(" top命令")]),t._v(" "),r("p",[t._v("动态监视进程所有状态。\n"),r("img",{attrs:{src:a(651),alt:""}}),t._v("\n有几个没说的字段需要补充。")]),t._v(" "),r("ul",[r("li",[t._v("PR：进程的优先级。")]),t._v(" "),r("li",[t._v("VIRT：进程的虚拟内存。")]),t._v(" "),r("li",[t._v("COMMAND:启动该进程需要的命令。")])]),t._v(" "),r("h4",{attrs:{id:"kill命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kill命令"}},[t._v("#")]),t._v(" kill命令")]),t._v(" "),r("p",[t._v('用于删除执行中的程序或工作。\n用的最多的就是kill -9 ["进程名"]or[进程号]')])])}),[],!1,null,null,null);s.default=_.exports}}]);