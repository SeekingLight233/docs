(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{605:function(t,v,_){t.exports=_.p+"assets/img/01.aacd023e.png"},606:function(t,v,_){t.exports=_.p+"assets/img/02.5b7b572e.png"},607:function(t,v,_){t.exports=_.p+"assets/img/03.b2c69809.png"},608:function(t,v,_){t.exports=_.p+"assets/img/04.845813c6.jpg"},609:function(t,v,_){t.exports=_.p+"assets/img/05.849cebc0.png"},610:function(t,v,_){t.exports=_.p+"assets/img/06.0f903f66.png"},611:function(t,v,_){t.exports=_.p+"assets/img/07.46e70389.png"},771:function(t,v,_){"use strict";_.r(v);var s=_(8),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"服务器与应用层协议之间的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务器与应用层协议之间的关系"}},[t._v("#")]),t._v(" 服务器与应用层协议之间的关系")]),t._v(" "),s("p",[t._v("服务器端使用TCP或者UDP的端口侦听客户端请求")]),t._v(" "),s("p",[t._v("客户端使用IP地址来定位主机，用目标的端口来定位服务。")]),t._v(" "),s("p",[t._v("服务器网卡上可以设置开放的端口号，实现网络安全。")]),t._v(" "),s("h2",{attrs:{id:"udp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[t._v("#")]),t._v(" UDP")]),t._v(" "),s("h3",{attrs:{id:"头部结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#头部结构"}},[t._v("#")]),t._v(" 头部结构")]),t._v(" "),s("p",[s("img",{attrs:{src:_(605),alt:""}})]),t._v(" "),s("p",[t._v("头部占8个字节，其中的每个字段都包含两个字节，分别包括源"),s("strong",[t._v("端口，目标端口，长度，校验和")]),t._v("，同时还有12个字节的伪首部。")]),t._v(" "),s("p",[t._v("PS：这张图是自顶向下中的，32比特的意思是结构的“宽度”是4个字节。")]),t._v(" "),s("h3",{attrs:{id:"特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),s("ul",[s("li",[t._v("面向无连接：说白了就是想发就发，不管你有没有收到。")]),t._v(" "),s("li",[t._v("不可靠性：既然想发就发，肯定就不可靠啦，网络一炸就掉包了")]),t._v(" "),s("li",[t._v("高效：没TCP那么墨迹，它只需要保证数据发出去并且能有序到达就OK")]),t._v(" "),s("li",[t._v("传输方式灵活：不但支持一对一，也可以支持一对多，多对多，多对一，想咋发就咋发。")])]),t._v(" "),s("h3",{attrs:{id:"适用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#适用场景"}},[t._v("#")]),t._v(" 适用场景")]),t._v(" "),s("ul",[s("li",[t._v("直播，视频通话")]),t._v(" "),s("li",[t._v("对即时通讯要求高的网络游戏（LOL(MOBA)，彩6这种）")])]),t._v(" "),s("h2",{attrs:{id:"tcp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[t._v("#")]),t._v(" TCP")]),t._v(" "),s("h3",{attrs:{id:"头部结构-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#头部结构-2"}},[t._v("#")]),t._v(" 头部结构")]),t._v(" "),s("p",[s("img",{attrs:{src:_(606),alt:""}})]),t._v(" "),s("p",[t._v("头部最少占20个字节，其中源端口号和目标端口号还是各占两个字节，校验和也是占两个字节，除此之外还包括：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("序号：占4个字节 对每个字节流进行编号，如果序号为600，则说明这个数据包的第一个字节为600，最后一个字节就是600+数据包的长度")])]),t._v(" "),s("li",[s("p",[t._v("确认号：4个字节，用来表示一个数据包的下一个字节的编号是多少，同时也表示本数据包已经送到，（暂时理解为当前数据包的最后一个字节的序号）")])]),t._v(" "),s("li",[s("p",[t._v("窗口：两个字节，表示还能接受多少字节的数据，用于流量控制")])]),t._v(" "),s("li",[s("p",[t._v("紧急数据指针：两个字节，指出紧急数据的位置，只有在URG为1时才有效")]),t._v(" "),s("p",[t._v("这还没完，还有6bit的标识符")]),t._v(" "),s("ol",[s("li",[t._v("URG为1时，激活紧急数据指针")]),t._v(" "),s("li",[t._v("ACK为1时，说明确认号字段（小ack）有效")]),t._v(" "),s("li",[t._v("PSH为1时，表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。")]),t._v(" "),s("li",[t._v("RST为1，说明TCP连接有问题，要重新连")]),t._v(" "),s("li",[t._v("SYN一般情况为1，配合ACK使用。当ACK为0时，说明当前包为连接请求。\n当SYN为0，说明连接建立好了。")]),t._v(" "),s("li",[t._v("FIN为1，表示数据已经发完了，并要求释放连接。")])])])]),t._v(" "),s("h3",{attrs:{id:"套接字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#套接字"}},[t._v("#")]),t._v(" 套接字")]),t._v(" "),s("p",[t._v("socket = (IP地址：端口号)\n一个TCP连接由两个端点（两个套接字）来决定。")]),t._v(" "),s("h3",{attrs:{id:"建立连接时的三次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#建立连接时的三次握手"}},[t._v("#")]),t._v(" 建立连接时的三次握手")]),t._v(" "),s("p",[s("img",{attrs:{src:_(607),alt:"03"}})]),t._v(" "),s("ol",[s("li",[s("p",[t._v("第一次握手，客户端向服务器发送"),s("strong",[t._v("连接请求报文")]),t._v("，该报文段包含了一个自己的初始序号X。")])]),t._v(" "),s("li",[s("p",[t._v("第二次握手，如果同意连接，服务器就会返回一个"),s("strong",[t._v("连接确认报文")]),t._v("，该报文中也包含了一个初始序号Y。")])]),t._v(" "),s("li",[s("p",[t._v("第三次握手，客户端还要再向服务器发送一个"),s("strong",[t._v("连接确认报文")]),t._v("，此时的确认号是Y＋1，序号是X＋1，用来保证这次的连接确认报文的确是“关于”前两次握手的，如果没有这第三次握手，那么在网络出现阻塞时就会产生问题——一旦网络请求在网络中滞留的时间过长，客户端就会"),s("strong",[t._v("重新发一个请求")]),t._v("。那之前发的请求怎么办？还停在网络中呢，之前的“作废请求”到达客户机只是一个时间问题。因此第三次握手是一个非常好的保证方式，保证客户端会忽略前两次握手，不然服务器会直接打开两个连接通道。")]),t._v(" "),s("p",[s("strong",[t._v("第三次握手后")]),t._v("，连接通道打开。")])])]),t._v(" "),s("h3",{attrs:{id:"断开连接时的四次挥手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#断开连接时的四次挥手"}},[t._v("#")]),t._v(" 断开连接时的四次挥手")]),t._v(" "),s("p",[s("img",{attrs:{src:_(608),alt:""}})]),t._v(" "),s("ol",[s("li",[t._v("第一次挥手，客户端发送"),s("strong",[t._v("连接释放请求")]),t._v("。（FIN为1）")]),t._v(" "),s("li",[t._v("第二次挥手，服务器收到请求，先往上告诉应用层“TCP要关了。。”接着给客户端返回一个ACK，再接着就进入了一个“半关闭”（CLOSE-WAIT）的状态，在这个状态中，B还是可以给A发送数据的。")]),t._v(" "),s("li",[t._v("第三次挥手，此时数据应该是“彻底发完了”，服务器发送"),s("strong",[t._v("连接释放请求")]),t._v('（FIN为1），并进入到**"最后确认阶段"（LAST－ACK）**')]),t._v(" "),s("li",[t._v("第四次挥手，客户端受到连接释放请求后，会再向服务器发送一个ACK，告诉服务器“自己听到了它的连接释放请求”，当服务器收到这个ACK后，便会最终进入CLOSED状态。而客户端在发完ACK后便会进入到一个"),s("strong",[t._v("TIME－WAIT")]),t._v("的状态，该状态会持续两个MSL（Maximum Segment Lifetime)。该状态的存在是为了防止另外一种情况：假设第四次挥手时的ACK在网络中滞留了，那么服务器就会在一定时间后"),s("strong",[t._v("重新发送连接释放请求")]),t._v("，这2MSL的时间主要是为了等这玩意儿。")])]),t._v(" "),s("h3",{attrs:{id:"特性-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特性-2"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),s("p",[t._v("面向连接\n点对点\n可靠交付\n全双工\n面向字节流")]),t._v(" "),s("h4",{attrs:{id:"传输可靠"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传输可靠"}},[t._v("#")]),t._v(" 传输可靠")]),t._v(" "),s("h5",{attrs:{id:"停止等待协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#停止等待协议"}},[t._v("#")]),t._v(" 停止等待协议")]),t._v(" "),s("p",[t._v("（超时重传机制）保证了保证了数据可以准确送达。")]),t._v(" "),s("h5",{attrs:{id:"滑动窗口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口"}},[t._v("#")]),t._v(" 滑动窗口")]),t._v(" "),s("p",[t._v("滑动窗口是TCP流量控制的具体实现。")]),t._v(" "),s("p",[s("img",{attrs:{src:_(609),alt:""}})]),t._v(" "),s("p",[s("img",{attrs:{src:_(610),alt:"06"}})]),t._v(" "),s("p",[t._v("发送端窗口的大小是由接受窗口决定的，接收端会告诉发送端自己的剩余窗口大小，然后发送端会再根据网络情况设置一个合适的大小。当发送端收到应答报文"),s("strong",[t._v("之后")]),t._v("，会将滑动窗口向右滑动。")]),t._v(" "),s("p",[t._v("如果给窗口字段设置为0，则发送方久无法发送数据了。")]),t._v(" "),s("p",[t._v("如果出现发送失败需要重传的情况，会先处理发送窗口需要处理的其他数据段。")]),t._v(" "),s("p",[t._v("滑动窗口可以让TCP实现流量控制功能，不然就会出现接收方网络差的要死（带宽已经占完），发送方还一直发数据的情况。")]),t._v(" "),s("h4",{attrs:{id:"拥塞控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#拥塞控制"}},[t._v("#")]),t._v(" 拥塞控制")]),t._v(" "),s("p",[t._v("当网络出现拥塞的时候，数据包就有可能会丢，此时发送方就会重传，但问题是你越传网络就会越堵啊。。。此时拥塞控制就显得很重要了。")]),t._v(" "),s("p",[s("img",{attrs:{src:_(611),alt:"07"}})]),t._v(" "),s("p",[t._v("TCP实现拥塞控制的四个算法")]),t._v(" "),s("ul",[s("li",[t._v("慢开始: 刚开始的时候慢点传数据，然后在传输的过程中将发送窗口逐渐指数级扩大，避免一开始就发送大量数据直接把网给搞炸，其实很好理解，想想你百度云下东西的时候是逐渐变快的，而不是上来就满宽带（PS：前提是你开了百度云Svip）。")]),t._v(" "),s("li",[t._v("拥塞避免：当传输过程中发生拥塞时，发送窗口停止指数扩大，并将阈值设置为当前窗口的一半。发送窗口在每个RTT只会＋1。")]),t._v(" "),s("li",[t._v("快重传：如果发送方收到三个相同的，此时便知道自己的接下来的数据没发出去，发送方会立即停止当前数据发送并快速发送没发出去的数据。")]),t._v(" "),s("li",[t._v("快恢复：在执行快重传时，发送方知道自己只是丢了个别的报文段，没有必要慢开始，直接"),s("strong",[t._v("快恢复")]),t._v("：将阈值砍一半，然后直接把窗口拉满（窗口值和阈值此时相等），然后执行拥塞避免算法。（既然丢数据那就说明网络有些顶不住了，转为拥塞避免算法是最为稳妥的选择。）")])]),t._v(" "),s("blockquote",[s("p",[t._v("当")])]),t._v(" "),s("h3",{attrs:{id:"适用场景-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-2"}},[t._v("#")]),t._v(" 适用场景")]),t._v(" "),s("p",[t._v("强调数据完整性的应用，像下载器，企业客户端应用，HTTP，FTP等文件传输协议，POP，SMTP等邮件传输协议。")])])}),[],!1,null,null,null);v.default=a.exports}}]);